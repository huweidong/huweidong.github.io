---
title: tips笔记总结
---

### tableViewCell里面图片圆角离屏渲染解决方案
撰写一个[UIImageView的分类](https://github.com/MyExam-hu/SummaryPro/blob/master/SummaryPro/Category/UIImageView%2BImageViewRadius.m),分类仿写SDWebImage里面加载图片的方法把图片加载下来后,通过[另外一个UIImage分类](https://github.com/MyExam-hu/SummaryPro/blob/master/SummaryPro/Category/UIImage%2BImageRadius.m)用贝塞尔曲线切圆角处理,然后根据和SDWebImage的逻辑一样保留圆角图片缓存,清除原有非圆角图片缓存

### 字典深浅拷贝
```
NSMutableDictionary *myDic=[@{@"22":@"33"} mutableCopy];
NSMutableDictionary *otherDic=myDic;
//NSMutableDictionary *otherDic=[myDic mutableCopy];
[otherDic setValue:@"33" forKey:@"44"];
```
改变可变字典otherDic时myDic也会同时改变,所以使用可变字典时要让两个字典独立需要注意使用mutableCopy.

### NSMutableSet里面尽量少用不可变对象
```
NSMutableSet *set=[NSMutableSet new];
NSMutableArray *arrayA=[@[@1,@2] mutableCopy];
[set addObject:arrayA];
NSLog(@"set=%@",set);
    
NSMutableArray *arrayB=[@[@1,@2] mutableCopy];
[set addObject:arrayB];
NSLog(@"set=%@",set);
    
NSMutableArray *arrayC=[@[@1] mutableCopy];
//[set addObject:[arrayC copy]];
[set addObject:arrayC];
NSLog(@"set=%@",set);
    
[arrayC addObject:@2];
NSLog(@"set=%@",set);
    
NSSet *setB=[set copy];
NSLog(@"setB=%@",setB);
```
如上面代码所示使用可变对象时会出现里面有相同元素的情况,而当重新将其浅拷贝的时候则里面内容会转回不可变对象,所以才会恢复正常.

### 打印输出黑科技
重写实体类如下方法然后就可以直接通过NSLog(@"cls=%@",cls)输出定制的内容

```
- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, %@", [self class],self,@{@"youName":_youName,                                                                                             @"myName":_myName}];
}
//debug环境下
- (NSString *)debugDescription {
//    return [NSString stringWithFormat:@"<%@: %p, %@", [self class],self,@{@"youName":_youName,
//                                                                          @"myName":_myName}];
    return [self description];
}
```

### 替换两个方法的实现
```
Method originalMethod=class_getInstanceMethod([NSString class], @selector(lowercaseString));
Method swappedMethod=class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString));
method_exchangeImplementations(originalMethod, swappedMethod);
```
替换两个方法的实现达到输出测试结果的目的(作用范围,整个运行期),或者如AFNetworking中的替换掉NSUrlSession中的resume和suspend方法为自身逻辑服务.

### 关联对象方法的使用
```
-(void)loadAlertView{
    UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@"Question" message:@"2333" delegate:self cancelButtonTitle:@"Cancel" otherButtonTitles:@"Submit", nil];
    void (^block)(NSInteger) = ^(NSInteger btnIndex){
        if (btnIndex==0) {
            NSLog(@"0000");
        }else{
            NSLog(@"other");
        }
    };
    objc_setAssociatedObject(alert, EOCMYAlertViewKey, block, OBJC_ASSOCIATION_COPY);
    [alert show];
}

#pragma mark - UIAlertViewDelegate
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 9_0){
    void (^block)(NSInteger)=objc_getAssociatedObject(alertView, EOCMYAlertViewKey);
    block(buttonIndex);
}
```
使用关联对象方法可以把逻辑集中写在定义控件的地方使得逻辑不会过于分散.

### 基于运行期OC的Get方法和Set方法的实现
```
//动态方法解析函数
+(BOOL)resolveInstanceMethod:(SEL)sel{
    NSString *selectorString=NSStringFromSelector(sel);
    if ([selectorString hasPrefix:@"set"]) {
        class_addMethod(self, sel, (IMP)autoDictionarySetter, "v@:@");
    }else{
        class_addMethod(self, sel, (IMP)autoDictionaryGetter, "@@:");
    }
    return YES;
}

id autoDictionaryGetter(id self,SEL _cmd){
    EOCAutoDictionary *typeSelf=(EOCAutoDictionary *)self;
    NSMutableDictionary *backingStore=typeSelf.backingStore;
    NSString *key=NSStringFromSelector(_cmd);
    return [backingStore objectForKey:key];
}

void autoDictionarySetter(id self,SEL _cmd,id value){
    EOCAutoDictionary *typeSelf=(EOCAutoDictionary *)self;
    NSMutableDictionary *backingStore=typeSelf.backingStore;
    
    NSString *selectorString=NSStringFromSelector(_cmd);
    NSMutableString *key=[selectorString mutableCopy];
    
    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];
    
    [key deleteCharactersInRange:NSMakeRange(0, 3)];
    
    NSString *lowercaseFirstChar=[[key substringToIndex:1] lowercaseString];
    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];
    if (value) {
        [backingStore setObject:value forKey:key];
    }else{
        [backingStore removeObjectForKey:key];
    }
}
```
当对象在收到无法解读的消息后,首先调用其所属类的下列类方法

 +(BOOL)resolveInstanceMethod:(SEL)sel
 
 所以可以利用其消息转发机制的这个函数来重新get,set方法,[完整代码链接](https://github.com/MyExam-hu/SummaryPro/blob/master/SummaryPro/Class/EOCAutoDictionary.m).